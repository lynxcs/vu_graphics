<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Sean Bradley" />
    <title>Draw a Displacement Map</title>
    <meta name="description" content="Three.js TypeScript Tutorials by Sean Bradley : https://sbcode.net/threejs" />
    <style>
        body {
            overflow: hidden;
            margin: 0px;
        }

        #instructions {
            color: white;
            position: absolute;
            left: 50%;
            top: 10px;
            margin-left: -220px;
            font-family: monospace;
        }

        #canvasD {
            position: absolute;
            background-color: #000000;
            left: 0px;
            top: 50px;
        }

        #canvasN {
            position: absolute;
            background-color: #000000;
            left: 0px;
            top: 180px;
        }
    </style>
    <script type="importmap">
            {
                "imports": {
                    "three": "/build/three.module.min.js",
                    "dat.gui": "/dat.gui"
                }
            }
        </script>
</head>

<body>
    <div id="instructions">
        Hold down <kbd>CTRL</kbd> key<br /> and
        left mouse button to draw.
    </div>
    <canvas id="canvasD" height="128" width="128"></canvas>
    <canvas id="canvasN" height="128" width="128"></canvas>
    <script type="module">
        import * as THREE from 'three'
        import { OrbitControls } from '/jsm/controls/OrbitControls.js'
        import Stats from '/jsm/libs/stats.module.js'
        import { GUI } from 'dat.gui'

        const scene = new THREE.Scene()

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)
        camera.position.set(0, 0.75, 0.25)

        const light = new THREE.DirectionalLight()
        light.position.set(1, 1, 1)
        scene.add(light)

        scene.background = new THREE.Color( 0xa0a0a0 );
		scene.fog = new THREE.Fog( 0xa0a0a0, 10, 50 );

        //const newlight = new THREE.
        const light2 = new THREE.AmbientLight( 0x404040 ); // soft white light
        scene.add( light2 );

        const renderer = new THREE.WebGLRenderer()
        renderer.setSize(window.innerWidth, window.innerHeight)
        document.body.appendChild(renderer.domElement)

        const controls = new OrbitControls(camera, renderer.domElement)
        controls.enablePan = false
        controls.enableDamping = true

        const canvasD = document.getElementById('canvasD')
        const contextD = canvasD.getContext('2d')
        const canvasN = document.getElementById('canvasN')
        const contextN = canvasN.getContext('2d')
        contextN.fillStyle = '#7f7fff'
        contextN.fillRect(0, 0, 128, 128)
        contextD.fillStyle = '#FFFFFF'
        contextD.fillRect(0, 0, 128, 128)
        contextD.fillStyle = '#000000'
        contextD.fillRect(0, 0, 128, 3);
        contextD.fillRect(0, 0, 3, 128);
        contextD.fillRect(125, 0, 3, 128);
        contextD.fillRect(0, 125, 128, 3);
        height2normal(contextD, contextN);


        const displacementMap = new THREE.CanvasTexture(canvasD)
        const normalMap = new THREE.CanvasTexture(canvasN)

        const geometry = new THREE.PlaneGeometry(1, 1, 128, 128)
        const material = new THREE.MeshStandardMaterial({
            displacementMap: displacementMap,
            displacementScale: 0.1,
            normalMap: normalMap,
        })

        const plane = new THREE.Mesh(geometry, material)
        plane.rotation.x = -Math.PI / 2
        scene.add(plane)

        const geometry2 = new THREE.PlaneGeometry(2, 2, 256, 256)
        const material2 = new THREE.MeshStandardMaterial({
            color: '0xFF0000'
        });

        const plane2 = new THREE.Mesh(geometry2, material2)
        plane2.rotation.x = -Math.PI / 2
        scene.add(plane2)

        const raycaster = new THREE.Raycaster()
        let intersects
        const mouse = new THREE.Vector2()
        let ctrlDown = false
        let ptrDown = false

        function initDisplacement() {
            contextN.fillStyle = '#7f7fff'
            contextN.fillRect(0, 0, 128, 128)
            contextD.fillStyle = '#FFFFFF'
            contextD.fillRect(0, 0, 128, 128)
            contextD.fillStyle = '#000000'
            contextD.fillRect(0, 0, 128, 3);
            contextD.fillRect(0, 0, 3, 128);
            contextD.fillRect(125, 0, 3, 128);
            contextD.fillRect(0, 125, 128, 3);
            material.needsUpdate = true
            material.displacementMap.needsUpdate = true
            height2normal(contextD, contextN);
            material.normalMap.needsUpdate = true
        }
        
        const controlParameters = {
            brushSize: 4,
            brushPower: -8,
            resetDisplacement: function() {
                initDisplacement();
            }
        }

        // height2normal - based on www.mrdoob.com/lab/javascript/height2normal/
        function height2normal(context, contextN) {
            var width = 128
            var height = 128

            var src = context.getImageData(0, 0, width, height)
            var dst = contextN.createImageData(width, height)

            for (var i = 0, l = width * height * 4; i < l; i += 4) {
                var x1, x2, y1, y2

                if (i % (width * 4) == 0) {
                    // left edge
                    x1 = src.data[i]
                    x2 = src.data[i + 4]
                } else if (i % (width * 4) == (width - 1) * 4) {
                    // right edge
                    x1 = src.data[i - 4]
                    x2 = src.data[i]
                } else {
                    x1 = src.data[i - 4]
                    x2 = src.data[i + 4]
                }

                if (i < width * 4) {
                    // top edge
                    y1 = src.data[i]
                    y2 = src.data[i + width * 4]
                } else if (i > width * (height - 1) * 4) {
                    // bottom edge
                    y1 = src.data[i - width * 4]
                    y2 = src.data[i]
                } else {
                    y1 = src.data[i - width * 4]
                    y2 = src.data[i + width * 4]
                }

                dst.data[i] = x1 - x2 + 127
                dst.data[i + 1] = y1 - y2 + 127
                dst.data[i + 2] = 255
                dst.data[i + 3] = 255
            }

            contextN.putImageData(dst, 0, 0)
        }

        function clamp(min, max, number) {
            return Math.max(min, Math.min(number, max));
        }

        function increasePixelValues(x, y, width, height, increaseBy, ctx) {
            // Get the image data for the specified region
            const imageData = ctx.getImageData(x, y, width, height);
            const data = imageData.data;

            // Loop through the pixel data (RGBA format, so every 4th value is alpha)
            for (let i = 0; i < data.length; i += 3) {
                data[i] = clamp(0, 255, data[i] + increaseBy);     // Red
                data[i + 1] = clamp(0, 255, data[i + 1] + increaseBy); // Green
                data[i + 2] = clamp(0, 255, data[i + 2] + increaseBy); // Blue
            }

            // Put the modified image data back onto the canvas
            ctx.putImageData(imageData, x, y);
        }

        function draw(uv) {
            // contextD.fillStyle = '#AAAAAA'
            // contextD.fillRect(uv.x * 128, 128 - uv.y * 128, 2, 2)
            increasePixelValues(uv.x * 128, 128 - uv.y * 128, controlParameters.brushSize, controlParameters.brushSize, controlParameters.brushPower, contextD)
            material.needsUpdate = true
            material.displacementMap.needsUpdate = true
            height2normal(contextD, contextN)
            material.normalMap.needsUpdate = true
        }

        function raycast() {
            raycaster.setFromCamera(mouse, camera)
            intersects = raycaster.intersectObject(plane, false)
            if (intersects.length > 0) {
                draw(intersects[0].uv)
            }
        }

        document.addEventListener('mousemove', function (event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1
            if (ctrlDown && ptrDown) raycast()
        })

        renderer.domElement.addEventListener('pointerdown', function () {
            ptrDown = true
            if (ctrlDown) raycast()
        })

        renderer.domElement.addEventListener('pointerup', function () {
            ptrDown = false
        })

        window.addEventListener('keydown', function (event) {
            if (event.key === 'Shift') {
                renderer.domElement.style.cursor = 'crosshair'
                controls.enabled = false
                ctrlDown = true
            }
        })

        window.addEventListener('keyup', function (event) {
            if (event.key === 'Shift') {
                renderer.domElement.style.cursor = 'pointer'
                controls.enabled = true
                ctrlDown = false
            }
        })

        window.addEventListener('resize', onWindowResize, false)
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight
            camera.updateProjectionMatrix()
            renderer.setSize(window.innerWidth, window.innerHeight)
            render()
        }

        const stats = new Stats()
        document.body.appendChild(stats.dom)

        const gui = new GUI()
        gui.add(material, 'displacementScale', 0, 0.2, 0.01)
        gui.add(controlParameters, 'brushSize', 1, 64, 4)
        gui.add(controlParameters, 'brushPower', -255, 255, -8)
        gui.add(controlParameters, 'resetDisplacement')

        function animate() {
            requestAnimationFrame(animate)

            controls.update()

            render()

            stats.update()
        }

        function render() {
            renderer.render(scene, camera)
        }

        animate()
    </script>
</body>

</html>